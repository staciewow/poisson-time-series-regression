#import data
library(readr)
data <-  read.csv("/Beijing_PM2_5_Sept20_Oct19.csv")

library(plyr)
library(zoo)
smo_data <- ddply(data, .(month), transform, pm2.5=na.approx(pm2.5, rule=2))
data_ts <- ts(smo_data$pm2.5, frequency = 7*24, start = c(0))
plot.ts(data_ts, xlab = "week", ylab = "Measure of pm2.5 in Beijing")

###We also check the random component, seasonal component and trend component of pm2.5 measures. Since our seasonality trend seems pretty stable, we prefer additive over multiplicative.

library(tseries)
components <- decompose(data_ts, type = "additive") #preferred!!
plot(components)

###Now, we recode pm2.5 measures as 1 and 0. If during that hour, the pm2.5 reached the goal (pm <= 60), it's recoded as 1; if during that hour, the pm2.5 did not reach the goal (pm > 60), it's recoded as 0. Then, we further aggregated the hourly data onto the daily level and calculated the number of hours in a day that had reached the pm2.5 goal (goal.df). This whole section here is all about data-processing.

smo_data$pm2_5_recode[smo_data$pm2.5 <= 60] <- 1  #reached the goal
smo_data$pm2_5_recode[smo_data$pm2.5 > 60] <- 0  #not reached the goal
library(dplyr)
pm_day <- smo_data %>% 
  group_by(month, day, pm2_5_recode) %>%
  summarise(goal = n())
df <- data.frame(month = rep(9, 22), day = rep(20:30,2), pm2_5_recode = rep(0:1,11))
df2 <- data.frame(month = rep(10, 38), day = rep(1:19, 2), pm2_5_recode = rep(0:1,19))
df <- rbind(df, df2)
df <- merge(df, pm_day, by = c("month", "day", "pm2_5_recode"),all = TRUE)
df[is.na(df)] <- 0
goal.df <- df %>%
  filter(pm2_5_recode == 1)
  
###Now, we can start the process of poisson time series regression. 
#First off, we made the data (goal.df) a time series object, and then we plotted it. We plotted the data with seasonal, trend and irregular components assuming these components are multiplicative. We also used the boxplot to observe some seasonality (in our case, weekly trend). We observed that the count of hours that reached the PM2.5 goal, tends to be higher on Wednesdays and Thursdays. Like we mentioned earlier, PM2.5 fine particles can come from various sources, which include power plants, motor vehicles, airplanes, residential wood burning, forest fires, agricultural burning, volcanic eruptions and dust storms. For Beijing, the main source of PM2.5 fine particles is definitely from vehicle emissions. Beijing citizens tend to take public transportation to work during weekdays while during the weekend, people tend to drive individual vehicles to go out. This could be an explanation of the boxplot.

ts_goal <- ts(goal.df$goal, frequency = 7, start = c(1))  #make it a time-series object
plot.ts(ts_goal, xlab = "week", ylab = "Count of Hours Reached the PM2.5 Goal Per Day")
components <- decompose(ts_goal, type = "multiplicative")
plot(components)
boxplot(ts_goal~cycle(ts_goal)) 

###To check stationarity:
###ADF - we ended up getting p-value = 0.08026, which is larger than 0.05. Thus, the ADF test thinks that our data is non-stationary. After taking differencing 3 times, we finally received a p-value = 0.01, which is smaller than 0.05, to indicate our data is stationary. 
###KPSS - small p-values (e.g., less than 0.05) suggest that differencing is required. We also got p-value = 0.1 from KPSS, which is  larger than 0.05. So the KPSS suggests that our data in stationary.

library(tseries)
adf.test(ts_goal) #larger than 0.05, so non-stationary
kpss.test(ts_goal) #larger than 0.05, so stationary
#differcing
adf.test(diff(ts_goal))
adf.test(diff(diff(ts_goal)))
adf.test(diff(diff(diff(ts_goal))))

###We extracted the count of hours that reached the goal column and named it as "goal". Then we fit the data into a poisson time series regression mode.
goal <- goal.df[, c(4)] #this is the count of hours that reached the goal column
library(tscount)
fit <- tsglm(goal, model = list(past_obs = 1, past_mean = 13), xreg = goal, distr = c("poisson"))
fit
summary(fit)

###ARIMA(0,0,1) basically is the same as MA(1), which means our model only has 1 order of moving average. 
The formula generated by this model is : y_t = intercept + 0.4015*e_(t-1). 
We used this model to predict the number of hours that PM2.5 would reach the goal in the future 3 days, as shown by the plot.
library(forecast)
model <- auto.arima(ts_goal)
plot(forecast(model,3), xlab = "Week", ylab = "Count of Hours that Reached the Goal")
model
